-------------------------

-- The OUTPUT Clause

-------------------------

-- Normally, a modification statement simply changes data without returning any information about the affected rows. However, it's often useful to capture details from those rows -- for example, for troubleshooting, auditing, or archiving purposes. T-SQL

-- supports this capability through the OUTPUT clause, which can be added to INSERT, UPDATE, DELETE, & MERGE statements. In this clause, we specify which attributes we want to return from the rows being modified. The OUTPUT clause is similar in structure

-- to a SELECT clause, except that each referenced column must be prefixed with either the `inserted` or `deleted` keyword:

	-- In an INSERT statement, use `inserted` to refer to the newly added rows.

	-- In a DELETE statement, use `deleted` to refer to the rows being removed.

	-- In an UPDATE statement, use `deleted` for the old state of each row & `inserted` for the new state.

-- The OUTPUT clause returns a result set, much like a SELECT statement. To capture this output into a table, include an INTO clause with the target table name. If we want to return the modified rows to the caller & store a copy in a table, we can specify

-- two OUTPUT clauses -- one with the INTO clause & one without it.



-- The following sections illustrate how to use the OUTPUT clause with different types of modification statements.



---------------------------
-- INSERT with OUTPUT
---------------------------

-- A common use case for the OUTPUT clause in an INSERT statement is when we need to capture all identity values generated by the insert operation. The built-in `SCOPE_IDENTITY()` function returns only the last identity value produced in the current scope;

-- not all values created by a multi-row insert. The OUTPUT clause provides a simple solution.



-- We'll use a table named `dbo.T1` to demonstrate this technique. The table includes an identity column (`keycol`) & a data column (`datacol`):

USE TSQLV6;

DROP TABLE IF EXISTS dbo.T1;

CREATE TABLE dbo.T1 (
	keycol	INT				NOT NULL IDENTITY(1, 1) CONSTRAINT PK_T1 PRIMARY KEY,
	datacol	NVARCHAR(40)	NOT NULL
);



-- Suppose we want to insert a set of rows into `dbo.T1` based on a query against the `HR.Employees` table, & we want to return all newly generated identity values. To do this, add an OUTPUT clause to the INSERT statement & specify the columns to return:

INSERT INTO dbo.T1(datacol)
	OUTPUT inserted.keycol, inserted.datacol
		SELECT lastname
		FROM HR.Employees
		WHERE country = N'USA';

-- This statement inserts one row for each US employee & returns both the generated identity value (`keycol`) & the inserted data (`datacol`). A similar approach can be used when inserting rows that generate values from a sequence object via the NEXT VALUE

-- FOR function -- whether directly in the statement or through a default constraint.



-- The result set produced by the OUTPUT clause can also be directed into a table. The target can be:

	-- A permanent table

	-- A temporary table

	-- A table variable

-- Storing the output in a table lets us query or process the modified data after the fact. For example, the following code declares a table variable named `@NewRows`, performs another insert into `dbo.T1`, & captures the output rows in the variable.

-- Finally, it queries the table variable to display the stored results:

DECLARE @NewRows TABLE(keycol INT, datacol NVARCHAR(40));

INSERT INTO dbo.T1(datacol)
	OUTPUT inserted.keycol, inserted.datacol
	INTO @NewRows(keycol, datacol)
		SELECT lastname
		FROM HR.Employees
		WHERE country = N'UK';

SELECT * FROM @NewRows;

SELECT * FROM dbo.T1;



--------------------------
-- DELETE with OUTPUT
--------------------------

-- The following example demonstrates how to use the OUTPUT clause with a DELETE statement. First, create a copy of the `Sales.Orders` table in the `dbo` schema:

DROP TABLE IF EXISTS dbo.Orders;

CREATE TABLE dbo.Orders (
	orderid			INT				NOT NULL,
	custid			INT				NULL,
	empid			INT				NOT NULL,
	orderdate		DATE			NOT NULL,
	requireddate	DATE			NOT NULL,
	shippeddate		DATE			NULL,
	shipperid		INT				NOT NULL,
	freight			MONEY			NOT NULL
		CONSTRAINT DFT_Orders_freight DEFAULT(0),
	shipname		NVARCHAR(40)	NOT NULL,
	shipaddress		NVARCHAR(60)	NOT NULL,
	shipcity		NVARCHAR(15)	NOT NULL,
	shipregion		NVARCHAR(15)	NULL,
	shippostalcode	NVARCHAR(10)	NULL,
	shipcountry		NVARCHAR(15)	NOT NULL,
	CONSTRAINT PK_Orders PRIMARY KEY (orderid)
);
GO

INSERT INTO dbo.Orders SELECT * FROM Sales.Orders;



-- The following DELETE statement removes all orders placed before 2022. Using the OUTPUT clause, it also returns selected attributes from each deleted row:

DELETE FROM dbo.Orders
	OUTPUT
		deleted.orderid,
		deleted.orderdate,
		deleted.empid,
		deleted.custid
WHERE orderdate < '20220101';

-- This statement not only performs the deletion but also returns the affected rows as a result set -- effectively giving us a view of what was deleted.



-- If you want to archive the rows that are deleted, add an INTO clause & specify the archive table name as the target.



---------------------------
-- UPDATE with OUTPUT
---------------------------

-- When using the OUTPUT clause with an UPDATE statement, we can refer to both the old & new states of each modified row.

	-- Prefix columns with `deleted` to access the values before the update.

	-- Prefix columns with `inserted` to access the values after the update.

-- The allows us to return both versions of the updated data in a single result set -- for example, to log changes or audit modifications.



-- Before demonstrating the OUTPUT clause in an UPDATE, let's create a copy of the `Sales.OrderDetails` table in the `dbo` schema:

DROP TABLE IF EXISTS dbo.OrderDetails;

CREATE TABLE dbo.OrderDetails (
	orderid		INT				NOT NULL,
	productid	INT				NOT NULL,
	unitprice	MONEY			NOT NULL
		CONSTRAINT DFT_OrderDetails_unitprice DEFAULT(0),
	qty			SMALLINT		NOT NULL
		CONSTRAINT DFT_OrderDetails_qty DEFAULT(1),
	discount	NUMERIC(4, 3)	NOT NULL
		CONSTRAINT SFT_OrderDetails_discount DEFAULT(0),
	CONSTRAINT PK_OrderDetails PRIMARY KEY (orderid, productid),
	CONSTRAINT CHK_discount CHECK (discount BETWEEN 0 AND 1),
	CONSTRAINT CHK_qty CHECK (qty > 0),
	CONSTRAINT CHK_unitprice CHECK (unitprice >= 0)
);
GO

INSERT INTO dbo.OrderDetails SELECT * FROM Sales.OrderDetails;



-- The following UPDATE statement increases the discount by 5 percent for all order details with `productid = 51`. The OUTPUT clause returns both the old & new discount values for each modified row:

UPDATE dbo.OrderDetails
	SET discount += 0.05
OUTPUT
	inserted.orderid,
	inserted.productid,
	deleted.discount AS olddiscount,
	inserted.discount AS newdiscount
WHERE productid = 51;

-- This query updates the qualifying rows & simultaneously returns the product & order IDs along with their previous & updated discount values -- making it easy to track or log the exact changes applied.



-------------------------
-- MERGE with OUTPUT
-------------------------

-- We can also use the OUTPUT clause with a MERGE statement. However, unlike other modification statements, a single MERGE can perform multiple DML actions -- inserting, updating, & deleting rows -- all within one command. To identify which action produced

-- each output row, we can use the special `$action` within the OUTPUT clause. This function returns a string value indicating the operation that occurred: `'INSERT'`, `'UPDATE'`, or `'DELETE'`.



-- To demonstrate MERGE with OUTPUT, we'll use two tables: `dbo.Customers` & `dbo.CustomersStage`. The goal is to synchronise the target (`dbo.Customers`) with the source (`dbo.CustomersStage`) by updating existing rows, inserting new ones, & deleting

-- those that no longer exist in the source:

DROP TABLE IF EXISTS dbo.Customers, dbo.CustomersStage;
GO

CREATE TABLE dbo.Customers(
	custid		INT			NOT NULL,
	companyname	VARCHAR(25)	NOT NULL,
	phone		VARCHAR(20) NOT NULL,
	address		VARCHAR(50) NOT NULL,
	CONSTRAINT PK_Customers PRIMARY KEY (custid)
);

INSERT INTO dbo.Customers(custid, companyname, phone, address)
VALUES (1, 'cust 1', '(111) 111-1111', 'address 1'),
	   (2, 'cust 2', '(222) 222-2222', 'address 2'),
	   (3, 'cust 3', '(333) 333-3333', 'address 3'),
	   (4, 'cust 4', '(444) 444-4444', 'address 4'),
	   (5, 'cust 5', '(555) 555-5555', 'address 5');

CREATE TABLE dbo.CustomersStage (
	custid		INT			NOT NULL,
	companyname	VARCHAR(25)	NOT NULL,
	phone		VARCHAR(20) NOT NULL,
	address		VARCHAR(50) NOT NULL,
	CONSTRAINT PK_CustomersStage PRIMARY KEY (custid)
);

INSERT INTO dbo.CustomersStage(custid, companyname, phone, address)
VALUES (2, 'AAAAA', '(222) 222-2222', 'address 2'),
	   (3, 'cust 3', '(333) 333-3333', 'address 3'),
	   (5, 'BBBBB', 'CCCCC', 'DDDDD'),
	   (6, 'cust 6 (new)', '(666) 666-6666', 'address 6'),
	   (7, 'cust 7 (new)', '(777) 777-7777', 'address 7');



-- The following MERGE statement synchronises the data between the two tables & uses the OUTPUT clause to return information about the affected rows:

MERGE INTO dbo.Customers AS TGT
USING dbo.CustomersStage AS SRC
	ON TGT.custid = SRC.custid
WHEN MATCHED THEN 
	UPDATE SET
		TGT.companyname = SRC.companyname,
		TGT.phone = SRC.phone,
		TGT.address = SRC.address
WHEN NOT MATCHED THEN
	INSERT (custid, companyname, phone, address)
	VALUES (SRC.custid, SRC.companyname, SRC.phone, SRC.address)
WHEN NOT MATCHED BY SOURCE THEN
	DELETE
OUTPUT $action AS theaction, inserted.custid,
	deleted.companyname AS oldcompanyname,
	inserted.companyname AS newcompanyname,
	deleted.phone AS oldphone,
	inserted.phone AS newphone,
	deleted.address AS oldaddress,
	inserted.address AS newaddress;

-- This MERGE statement updates existing customers, inserts new ones, & deletes those no longer present in the source table. The OUTPUT clause returns both the old & new values for each affected row, along with the corresponding DML action:

	-- For INSERT actions: all references to `deleted` columns return NULL because there is no prior row.

	-- For DELETE actions: all references to `inserted` columns return NULL because the row no longer exists.

	-- For UPDATE actions: both `deleted` & `inserted` contain data -- the old & new versions, respectively.

-- The `$action` function clearly identifies which type of modification each output row corresponds to, making it especially useful for auditing, logging, or verification.



-------------------
-- Nested DML
-------------------

-- The OUTPUT Clause returns a row for every modified row. But what if we want to store only a subsert of those rows -- for example, for auditing purposes? T-SQL supports this through nested DML, which allows us to use the result set of a modification

-- (with OUTPUT) as input for another DML statement. This enables us to insert only the rows we need into the target table.



-- First, create copies of the `Production.Products` & `Production.ProductsAudit` tables in the `dbo` schema:

DROP TABLE IF EXISTS dbo.ProductsAudit, dbo.Products;

CREATE TABLE dbo.Products (
	productid		INT				NOT NULL,
	productname		NVARCHAR(40)	NOT NULL,
	supplierid		INT				NOT NULL,
	categoryid		INT				NOT NULL,
	unitprice		MONEY			NOT NULL
		CONSTRAINT DFT_Products_unitprice DEFAULT(0),
	discontinued	BIT				NOT NULL
		CONSTRAINT DFT_Products_discontinued DEFAULT(0),
	CONSTRAINT PK_Products PRIMARY KEY (productid),
	CONSTRAINT CHK_Products_unitprice CHECK (unitprice >= 0)
);

INSERT INTO dbo.Products SELECT * FROM Production.Products;

CREATE TABLE dbo.ProductsAudit (
	LSN			INT			NOT NULL IDENTITY PRIMARY KEY,
	TS			DATETIME2	NOT NULL DEFAULT(SYSDATETIME()),
	productid	INT			NOT NULL,
	colname		SYSNAME		NOT NULL,
	oldval		SQL_VARIANT NOT NULL,
	newval		SQL_VARIANT NOT NULL
);



-- Suppose we want to update all products supplied by `supplierid = 1`, increasing their price by 15%. We also want to audit only those rows where the old prices was less than 20 & the new price is greater than or equal to 20. We can achieve this using

-- nested DML: the OUTPUT clause produces a derived table, & an outer INSERT SELECT filters & inserts only the relevant rows into the audit table.

INSERT INTO dbo.ProductsAudit(productid, colname, oldval, newval)
	SELECT productid, N'unitprice', oldval, newval
	FROM (UPDATE dbo.Products
		      SET unitprice *= 1.15
		  OUTPUT
			  inserted.productid,
			  deleted.unitprice AS oldval,
			  inserted.unitprice AS newval
		  WHERE supplierid = 1) AS D
	WHERE oldval < 20.0 AND newval >= 20.0;

	-- The inner UPDATE statement modifies all qualifying products & outputs all updated rows.

	-- The outer SELECT filters only those rows that meet the auditing criteria.

	-- Only the filtered rows are inserted into `dbo.ProductsAudit`.

-- Query the audit table to verify:

SELECT * FROM dbo.ProductsAudit;

-- In this example, three products were updated, but only two met the filtering criteria, so only those two were recorded in the audit table.



-- After completing the examples, run the following code to clean up all tables:

DROP TABLE IF EXISTS dbo.OrderDetails, dbo.ProductsAudit, dbo.Products,
	dbo.Orders, dbo.Customers, dbo.T1, dbo.T2, dbo.MySequences, dbo.CustomersStage;